-- Implementação de uma consulta aninhada:
select * from PRODUTO
where not exists(
	select 1
	from CLIENTE
	where ID_CLIENTE = 1000
);
-- NESSA CONSULTA, NÃO IRÁ RETORNAR NADA, POIS A TABELA CLIENTE POSSUI VALOR COM O 'ID_CLIENTE' = 1000.

-- CONSULTA QUE UTILIZA PRODUTO CARTESIANO:
SELECT COUNT(S.NUMERO_DO_SERVICO) AS NUMERO_DE_SERVICOS, C.NOME AS NOME_DO_CLIENTE
FROM SERVICO_FEITO S, CLIENTE C
WHERE S.CLIENTE_CORRESPONDENTE = C.ID_CLIENTE
GROUP BY C.CLIENTE_CORRESPONDENTE;

-- CONSULTA QUE UTILIZA FUNÇÕES DE AGREGAÇÃO:
SELECT AVG(PRECO_DO_PRODUTO) AS MEDIA_DOS_PRECOS, COUNT(ID_PRODUTO) AS NUMERO_DE_PRODUTOS
FROM PRODUTO;

-- CONSULTAS QUE USAM PARÂMETROS DE PREDICADOS:
SELECT * FROM PRODUTO
WHERE ID_PRODUTO > 10 AND ID_PRODUTO < 20;

SELECT NOME_COMPLETO FROM CLIENTE
WHERE IDADE = 40 OR IDADE = 20;

SELECT ID_SERVICO_FEITO AS ID_DO_SERVICO
FROM SERVICO_FEITO
WHERE NUMERO_DO_SERVICO != 10;

SELECT S.CLIENTE_CORRESPONDENTE AS NUMERO_CLIENTE, C.NOME_COMPLETO 
FROM SERVICO_FEITO S, CLIENTE C
WHERE DATA_DE_REALIZACAO BETWEEN '2024-11-01' AND '2024-12-01'
GROUP BY CLIENTE_CORRESPONDENTE, NOME_COMPLETO;

-- CONSULTAS QUE USAM AGRUPAMENTO E ORDENAÇÃO:
SELECT A.PET_RELACIONADO AS NUMERO_DO_PET, P.NOME_DO_PET 
FROM AGENDA_DO_VETERINARIO A, PET P
WHERE PET_RELACIONADO = ID_DO_PET
ORDER BY PET_RELACIONADO;

SELECT A.DATA_DO_REGISTRO AS DATA_DA_CONSULTA, P.APELIDO AS APELIDO_DO_PET
FROM AGENDA_DO_VETERINARIO A, PET P
WHERE A.PET_RELACIONADO = P.ID_DO_PET
GROUP BY A.DATA_DO_REGISTRO, P.APELIDO;

-- CONSULTAS COM CONTROLE DE TRANSAÇÃO:

-- FAZENDO UMA INSERÇÃO SIMPLES E SALVANDO:
START TRANSACTION;

INSERT INTO PET(NOME_DO_PET, APELIDO, TIPO_DO_PET, DONO_DO_PET) VALUES
('NEGO NEY', 'NEGO', 1, 231);

COMMIT;

-- ALTERANDO UMA COLUNA DE TABELA E DEPOIS FAZENDO ROLLBACK:
START TRANSACTION;

ALTER TABLE TIPO_DE_PET
CHANGE COLUMN NOME_INDEFINIDIDO NOME_DO_TIPO VARCHAR(100) NOT NULL;

ROLLBACK;

COMMIT;

-- ALTERANDO O NIVEL DE ISOLAMENTO DO BANCO:
SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE; 

-- SIMULANDO DOIS USUÁRIOS LENDOS OS MESMOS VALORES NO SERVIDOR:
-- user01:
start transaction;
-- definiu o nivel de isolamento e começou uma transação
-- user02:
set transaction isolation level serializable;
start transaction;
-- Fez o mesmo que o user01.
-- user01:
insert into pessoa(primeiro_nome, sobrenome, data_de_nascimento, cidade, estado)
values
('sergio', 'barros', '1980-05-19', 'teresina', 'pi');
select * from pessoa;
-- inseriu valor na tabela e fez uma seleção(Onde o novo valor inserido irá aparecer).
-- user02:
select * from pessoa; /* esse comando não irá ser execultado, o banco irá tentar até perder a conexão com o
 servidor. Isso acontece porque o primeiro usuário ainda não terminou a sua transação(Deu commit). */
-- user01:
commit; -- salvou as alterações feitas.
-- user02:
select * from pessoa; -- Agora consegue acessar os valores, visto que a outra transação concorrente foi finalizada
commit; -- Termina a sua transação.	






